--- a/net/minecraft/world/entity/player/Player.java
+++ b/net/minecraft/world/entity/player/Player.java
@@ -11,6 +_,8 @@
 import java.util.Optional;
 import java.util.OptionalInt;
 import java.util.function.Predicate;
+
+import de.erethon.papyrus.CraftPDamageType;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.GlobalPos;
@@ -726,7 +_,7 @@
     }
 
     @Override
-    public boolean hurtServer(ServerLevel level, DamageSource damageSource, float amount) {
+    public boolean hurtServer(ServerLevel level, DamageSource damageSource, float amount, CraftPDamageType damageType) { // Papyrus - Add damage type
         if (this.isInvulnerableTo(level, damageSource)) {
             return false;
         } else if (this.abilities.invulnerable && !damageSource.is(DamageTypeTags.BYPASSES_INVULNERABILITY)) {
@@ -753,7 +_,7 @@
 
                 // return amount != 0.0F && super.hurtServer(level, damageSource, amount);
                 // CraftBukkit start - Don't filter out 0 damage
-                boolean damaged = super.hurtServer(level, damageSource, amount);
+                boolean damaged = super.hurtServer(level, damageSource, amount, damageType); // Papyrus - Add damage type
                 if (damaged) {
                     this.removeEntitiesOnShoulder();
                 }
@@ -1021,14 +_,14 @@
         // Paper start - PlayerAttackEntityEvent
         boolean willAttack = !this.cannotAttack(target); // Vanilla logic
         io.papermc.paper.event.player.PrePlayerAttackEntityEvent playerAttackEntityEvent = new io.papermc.paper.event.player.PrePlayerAttackEntityEvent(
-            (org.bukkit.entity.Player) this.getBukkitEntity(),
-            target.getBukkitEntity(),
-            willAttack
+                (org.bukkit.entity.Player) this.getBukkitEntity(),
+                target.getBukkitEntity(),
+                willAttack
         );
 
         if (playerAttackEntityEvent.callEvent() && willAttack) { // Logic moved to willAttack local variable.
-        // Paper end - PlayerAttackEntityEvent
-            float f = this.isAutoSpinAttack() ? this.autoSpinAttackDmg : (float)this.getAttributeValue(Attributes.ATTACK_DAMAGE);
+                // Paper end - PlayerAttackEntityEvent
+                float f = this.isAutoSpinAttack() ? this.autoSpinAttackDmg : (float) this.getAttributeValue(attackDamageType.advantage); // Papyrus - Add damage type
             ItemStack weaponItem = this.getWeaponItem();
             DamageSource damageSource = this.createAttackSource(weaponItem); final DamageSource dmgSourceFinal = damageSource; // Paper - damage events
             float attackStrengthScale = this.getAttackStrengthScale(0.5F);
@@ -1063,7 +_,13 @@
                     }
 
                     Vec3 deltaMovement = target.getDeltaMovement();
-                    boolean flag3 = target.hurtOrSimulate(damageSource, f2);
+                    boolean flag3;
+                    if (target instanceof LivingEntity livingEntity) {
+                        f2 = (float) getBukkitEntity().onAttack(livingEntity.getBukkitLivingEntity(), f2, attackDamageType.apiType);
+                        flag3 = livingEntity.hurtServer((ServerLevel) level(), damageSource, f2, attackDamageType);
+                    } else {
+                        flag3 = target.hurtOrSimulate(damageSource, f2);
+                    }
                     if (flag3) {
                         this.causeExtraKnockback(target, this.getKnockback(target, damageSource) + (flag1 ? 0.5F : 0.0F), deltaMovement);
                         if (isSweepAttack) {
@@ -1254,7 +_,7 @@
                     float f1 = this.getEnchantedDamage(livingEntity, var12, damageSource) * strengthScale;
                     // Paper start - Only apply knockback if the event is not canceled
                     livingEntity.lastDamageCancelled = false;
-                    if (livingEntity.hurtServer(serverLevel, damageSource.knownCause(org.bukkit.event.entity.EntityDamageEvent.DamageCause.ENTITY_SWEEP_ATTACK), f1) && !livingEntity.lastDamageCancelled) {
+                    if (livingEntity.hurtServer(serverLevel, damageSource.knownCause(org.bukkit.event.entity.EntityDamageEvent.DamageCause.ENTITY_SWEEP_ATTACK), f1, attackDamageType) && !livingEntity.lastDamageCancelled) {
                         // Paper end - Only apply knockback if the event is not canceled
                         livingEntity.knockback(0.4F, Mth.sin(this.getYRot() * (float) (Math.PI / 180.0)), -Mth.cos(this.getYRot() * (float) (Math.PI / 180.0)), this, io.papermc.paper.event.entity.EntityKnockbackEvent.Cause.SWEEP_ATTACK); // Paper - knockback events
                         EnchantmentHelper.doPostAttackEffects(serverLevel, livingEntity, damageSource);
